# 交互系统架构与数据交互说明

本文基于 OpenSpec 规格与现有实现，梳理当前交互评测系统在 Flow 架构下的登录跳转逻辑、页面数据提交协议，以及从“3 个交互端”演进到“5 个子模块”后的改造要点与风险。

编写日期：2025-11-18  
相关规范：`openspec/specs/assessment-core/spec.md`、`openspec/specs/data-format/spec.md`、`openspec/specs/submission/spec.md`、`openspec/specs/flow/spec.md`、`openspec/specs/integration/spec.md`  
相关实现：`src/shared/services/apiService.js`、`src/shared/services/submission/usePageSubmission.js`、`docs/flow-architecture-analysis.md`、`docs/需求-交互前端改造方案.md`、`docs/需求-后端接口与数据模型.md`、`docs/SUBMODULE_REGISTRATION_GUIDE.md`

---

## 一、登录阶段：后端返回哪些数据，用于指示前端进入哪一个 Flow 子模块的哪一页？

### 1.1 登录接口与响应结构

- 接口：`POST /stu/login`  
- 统一规范来源：
  - Assessment Core：`openspec/specs/assessment-core/spec.md`（“登录成功后按后端指示进入对应模块与页面”）
  - 后端需求：`docs/需求-后端接口与数据模型.md`（“登录扩展：返回 Flow 入口与进度”）
  - Flow 架构分析：`docs/flow-architecture-analysis.md`

#### 1.1.1 传统单模块模式（兼容）

当批次绑定的是“单模块”（例如只进入 7 年级交互），后端保持旧结构返回：

```json
{
  "code": 200,
  "msg": "成功",
  "obj": {
    "url": "/seven-grade",
    "pageNum": "13",
    "batchCode": "250619",
    "examNo": "1001",
    "studentName": "测试用户",
    "schoolCode": "24146",
    "schoolName": "某某学校"
  }
}
```

关键字段：
- `url`：必填。用于前端通过 `ModuleRegistry.getModuleByUrl(url)` 选择模块（参见 `openspec/project.md`）。
- `pageNum`：必填。模块内页码（字符串），用于：
  - 登录成功后定位初始页面；
  - 刷新时恢复（与 `core.page/pageNum` 一致）。
- `batchCode`：必填。后续提交 `/stu/saveHcMark` 时作为批次号。
- `examNo`：必填。考生唯一标识，也会写入本地命名空间（`core.auth/currentUser` 等）。

#### 1.1.2 Flow 拼装式模式（新架构）

当批次绑定的是某个 Flow（多个子模块拼装），后端返回统一的 Flow 入口和进度信息。规范来源：
- `docs/flow-architecture-analysis.md`
- `docs/需求-后端接口与数据模型.md`

典型响应：

```json
{
  "code": 200,
  "msg": "成功",
  "obj": {
    "url": "/flow/test-flow-1",
    "pageNum": "0.1",
    "batchCode": "250619",
    "examNo": "1001",
    "studentName": "测试用户",
    "schoolCode": "24146",
    "schoolName": "开发环境",

    "flowId": "test-flow-1",
    "progress": {
      "stepIndex": 0,
      "modulePageNum": "1"
    }
  }
}
```

在 Flow 模式下，指导前端“进入哪个子模块、哪一页”的关键字段是：

1. **`url`**
   - 必填，格式：`/flow/<flowId>`。
   - 决定使用 `FlowModule` 而不是传统 `ModuleRouter`。

2. **`flowId`**
   - 建议返回，用于显式标识 Flow。
   - 逻辑上与 `url` 中的 `<flowId>` 一致（冗余字段）。

3. **`progress.stepIndex`**
   - 必填，整数（从 0 开始）。
   - 表示当前在 Flow 中的第几步。
   - 该步对应哪一个子模块，由 FlowDefinition 中的 `steps[stepIndex].submoduleId` 决定。

4. **`progress.modulePageNum`**
   - 必填，字符串。
   - 表示当前子模块内部的页码（映射到该子模块的某个 `pageId`）。

5. **`pageNum`（兼容字段）**
   - 可选，用于兼容旧协议。
   - 可以是简单数字（如 `"13"`），也可以为 Flow 预留的“复合页码”格式（例如 `"M0:1"` 表示“第 0 步的第 1 页”）。
   - 当前设计中，以 `progress` 为主，`pageNum` 为兼容补充。

### 1.2 前端如何根据这些字段决定跳转到哪个子模块、哪一页？

相关行为由以下规范与实现共同约束：
- 登录后的“按 url 定位模块/Flow”：
  - `openspec/specs/assessment-core/spec.md`：「登录成功后按后端指示进入对应模块与页面」
  - `openspec/project.md`：「登录与路由：后端登录返回 `{ url, pageNum }`…前端通过 ModuleRouter 选择模块」
- Flow 路由与 ID 解析：
  - `src/flows/FlowModule.jsx`（`deriveFlowIdFromUrl` 及 `initialResolvedFlowId` 逻辑）
- Flow 定义与步骤解析：
  - `openspec/specs/flow/spec.md`（FlowDefinition/Progress 协议）
  - `docs/flow-architecture-analysis.md`（FlowDefinition 示例）

统一逻辑可以抽象为：

1. **登录成功**  
   前端获取 `obj` 中的：
   - `url`
   - `pageNum`
   - `flowId`（若存在）
   - `progress.stepIndex` & `progress.modulePageNum`（若存在）

2. **判断是传统模式还是 Flow 模式**
   - 若 `url` 不以 `/flow/` 开头：走传统 `ModuleRouter`。
   - 若 `url` 形如 `/flow/<flowId>`：进入 `FlowModule`。

3. **Flow 模式下的子模块与页码解析**  
   - `flowId`：
     - 从 `url`（`/flow/<flowId>`）解析；
     - 或直接使用 `obj.flowId`（作为冗余校验）。
   - 调用后端（或 Mock）提供的 `GET /api/flows/{flowId}`：
     - 获得 `FlowDefinition`：
       - `steps[]` 数组；
       - 每个 `steps[i].submoduleId` 标识一个子模块（如 `g7-experiment`、`g7-questionnaire` 等）。
   - 使用 `progress.stepIndex`：
     - 选择当前步骤：`const step = steps[progress.stepIndex]`；
     - 由此得到当前子模块 `submoduleId`。
   - 使用 `progress.modulePageNum`：
     - 作为该子模块内部的页码；
     - 由子模块 CMI 接口 `getInitialPage(subPageNum)` 计算真正的 `pageId`，并跳转到对应页。

4. **与旧协议的兼容**  
   - 如果 `progress` 缺失，可以回退到 `pageNum`：
     - 若为单一数字，则交给模块自身的 `getInitialPage(pageNum)`；
     - 若为复合页码（如 `"2.11"` / `"M2:11"`），可解析出子模块序号与页码，用于兼容过渡。

---

## 二、页面提交阶段：前端每一页向后端提交哪些数据？提交方式如何？

### 2.1 提交接口与协议

#### 2.1.1 接口与传输方式

统一规范：
- 接口：`POST /stu/saveHcMark`
- 请求格式：`multipart/form-data`（**不是 JSON**）
- 参数（FormData）：
  - `batchCode: string` —— 批次号（来自登录返回）
  - `examNo: string` —— 考生编号（来自登录返回）
  - `mark: string` —— `MarkObject` 的 JSON 字符串

规范来源：
- `openspec/project.md`（“提交协议：使用 submitPageMarkData(payload)…”）
- `openspec/specs/data-format/spec.md`
- `openspec/specs/submission/spec.md`
- `docs/flow-architecture-analysis.md`、`docs/需求-后端接口与数据模型.md`
- 实现：`src/shared/services/apiService.js:24-89`（`submitPageMarkData`）

#### 2.1.2 前端提交实现路径

前端统一使用 `usePageSubmission` Hook 将“页面提交 → 构建 MarkObject → 校验 → 调用 API”打通：

- Hook：`src/shared/services/submission/usePageSubmission.js`
- 依赖：
  - `createMarkObject`（标准化 MarkObject）
  - `validateMarkObject`（字段/事件校验）
  - `EventTypes`（事件枚举）
  - `enhancePageDesc`（Flow 前缀拼接）
  - `submitPageMarkData`（实际调用 `/stu/saveHcMark`）

调用链简化为：

```js
// 页面组件中
const { submit } = usePageSubmission({
  getUserContext: () => ({ batchCode, examNo }),
  buildMark: () => buildCurrentPageMark(),   // 构建 MarkInput
  getFlowContext: () => ({ flowId, submoduleId, stepIndex, pageId }),
  allowProceedOnFailureInDev: true,          // DEV 下可配置失败放行
});

// 点击“下一页”时
const ok = await submit();
if (ok) {
  // 导航到下一页
}
```

内部行为（见 `usePageSubmission.js`）：
- 填充 / 规范：
  - `operationList[].code`、`answerList[].code` 按索引统一重排为从 1 开始递增；
  - `beginTime`、`endTime` 缺省时补为当前时间（本地时间字符串）。
- Flow 相关增强：
  - 若提供 `getFlowContext`，则自动注入或修正一个 `flow_context` Operation；
  - 并使用 `enhancePageDesc` 在 `pageDesc` 前面追加 `[flowId/submoduleId/stepIndex]` 前缀。
- 校验：
  - 使用 `validateMarkObject(mark)` 按 Data Format Spec 进行字段与事件类型校验。
- 提交与重试：
  - 调用 `submitPageMarkData(payload)`：
    - 构造 FormData；
    - 通过 `fetch` 将数据发往 `/stu/saveHcMark`。
  - 遇到网络错误按 `[1000, 2000, 4000]` 毫秒退避重试，3 次失败后视为提交失败；
  - 若返回 `code === 401` 或错误信息包含“session 已过期”等，调用统一的 `handleSessionExpired`，清理状态并回登录。

### 2.2 MarkObject 结构与字段说明

标准定义见 `openspec/specs/data-format/spec.md`，这里结合实现汇总：

```ts
interface MarkObject {
  pageNumber: string;           // 逻辑页码，可为复合页码，如 "M1:11" 或 "1.11"
  pageDesc: string;             // 页面描述；在 Flow 模式下会被增强为 "[flowId/submoduleId/stepIndex] 原始描述"
  operationList: Operation[];   // 操作记录（操作日志）
  answerList: Answer[];         // 答案记录（特别用于问卷）
  beginTime: string;            // 开始时间，YYYY-MM-DD HH:mm:ss（客户端本地时间）
  endTime: string;              // 结束时间，YYYY-MM-DD HH:mm:ss
  imgList: any[];               // 图片列表（通常为空数组）
}

interface Operation {
  code: number;                 // 序号（从 1 开始连续递增）
  targetElement: string;        // 目标元素描述，如 "按钮:下一步" / "页面"
  eventType: string;            // 事件类型（来自 EventTypes 枚举）
  value: string | object;       // 操作值（flow_context 等事件为对象，其余大多为字符串）
  time: string;                 // 事件时间戳，YYYY-MM-DD HH:mm:ss
  pageId?: string;              // 可选，对应页面 ID（如 "Page_11_Task_Experiment"）
}

interface Answer {
  code: number;                 // 序号（从 1 开始连续递增）
  targetElement: string;        // 答题元素标识，如 "Q1"
  value: string;                // 答案内容
}
```

事件类型集合由 Data Format Spec 与 Submission Spec 统一约束，核心包括：
- 页面级事件：
  - `page_enter` / `page_exit`
  - `page_submit_success` / `page_submit_failed`
- 交互操作类事件：
  - `click`、`input`、`input_blur`
  - `radio_select`、`checkbox_check`、`checkbox_uncheck`
  - `modal_open`、`modal_close`、`view_material`
  - 实验相关：`simulation_timing_started`、`simulation_run_result`、`simulation_operation`
- 问卷事件：
  - `questionnaire_answer`
- Flow 相关：
  - `flow_context`（记录 `flowId/submoduleId/stepIndex/pageId` 等信息）

### 2.3 提交调用时机与页面关系

根据 Assessment Core 与 Submission Spec：

- 所有交互页面（包括实验与问卷）在“下一页”导航前必须提交当前页数据：
  - 若提交成功：
    - 记录 `page_submit_success` 事件；
    - 可以安全导航到下一页。
  - 若提交失败：
    - DEV 环境可配置“失败仍放行”；
    - PROD 环境默认阻止导航，要求用户重试或联系监考。
- 问卷页面：
  - 在 `MarkObject.answerList` 中记录题目答案；
  - 同时在 `operationList` 中记录 `questionnaire_answer` 等事件，便于后端行为分析。

---

## 三、从「三个交互端」到「五个子模块」的改造问题与解决思路

### 3.1 原有架构：三个“交互端”

根据《需求-交互前端改造方案》、《项目分析-测评模块现状与统一组件建议》等文档，原始系统大致有：
- **4 年级交互**：火车购票实验（整套交互与问卷混在一个模块中，或问卷较弱）。
- **7 年级交互**：蒸馒头实验 + 后续问卷，内部通过一个导航系统串联。
- **7 年级追踪**：蜂蜜黏度等追踪实验 + 问卷，同样以单模块形式存在。

核心问题：
- 三个模块各自实现提交、计时、页面框架与导航，缺乏统一规范；
- 难以直接按“子模块 + Flow”拼装，例如：
  - “7 年级交互 → 4 年级问卷”；
  - “7 年级追踪交互 → 7 年级追踪问卷 → 7 年级问卷”；
- 旧模块的登录逻辑通常只支持一种 URL 和页码模式，无法自然表达 Flow 中的位置。

### 3.2 新架构：五个子模块

为支持拼装式评测（Flow），交互端已经拆分并实现以下 5 个子模块（详见 `docs/SUBMODULE_REGISTRATION_GUIDE.md`）：

1. `g4-experiment` —— 四年级火车购票-交互（原“四年级交互”交互部分）
2. `g7-experiment` —— 七年级蒸馒头-交互（原“七年级交互”的 P02–P19）
3. `g7-questionnaire` —— 七年级蒸馒头-问卷（原“七年级交互”的 P20–P28）
4. `g7-tracking-experiment` —— 七年级追踪-交互实验（原“七年级追踪”的前半段）
5. `g7-tracking-questionnaire` —— 七年级追踪-问卷（原“七年级追踪”的问卷部分）

每个子模块对外只暴露标准化的 CMI 接口：
- `submoduleId`、`displayName`、`version`
- `Component({ userContext, initialPageId, options })`
- `getInitialPage(subPageNum)` / `getTotalSteps()` / `getNavigationMode(pageId)` / `getDefaultTimers()`
- `onInitialize` / `onDestroy`

FlowOrchestrator 只依赖上述接口与 FlowDefinition 中的 `steps[].submoduleId` 即可按步骤加载子模块。

### 3.3 改造原有三个模块时存在的主要问题

结合需求文档与架构分析，主要问题集中在以下几类：

#### 问题 1：导航与页面映射耦合，难以拆分子模块

- 现状：
  - 原 7 年级模块内部使用单一导航组件，页面编号与业务阶段（实验/问卷）混在一起；
  - 原 7 年级追踪与 4 年级也有各自的导航与页面路径，未按“交互”与“问卷”清晰拆分。
- 影响：
  - 无法简单“裁剪出一段页面作为子模块”而不破坏原有导航逻辑；
  - FlowOrchestrator 要求子模块能自行根据 `pageNum` / `subPageNum` 恢复页面，需要更清晰的页码映射。

**解决思路：**
- 在每个模块内引入统一的页面映射工具（参考 `openspec/specs/assessment-core/spec.md` 中的 `getTargetPageIdFromPageNum` 约定）；
- 在内部逻辑中，将“实验页”与“问卷页”通过配置映射分组：
  - 例如，在 7 年级模块中：
    - P02–P19 归属于 `g7-experiment`；
    - P20–P28 归属于 `g7-questionnaire`；
- 子模块包装器层通过配置决定：
  - 当前子模块负责的页码范围；
  - 入口页、完成页、问卷页等特殊页的映射。

#### 问题 2：提交与计时逻辑分散且不统一

- 现状：
  - 三个模块对 `/saveHcMark` 的调用逻辑各不相同，部分使用旧版封装；
  - 计时器的起停、超时跳转也由各自模块内部控制；
  - 401 会话过期、网络错误等处理路径不统一。
- 影响：
  - 子模块拆分后，若仍沿用旧提交逻辑，会破坏 Flow 层面的一致性和监控；
  - DIff module 很难统一观测“是否提交成功 / 是否有 flow_context / 页码与 Flow 步骤对齐”等。

**解决思路：**
- 按 `docs/需求-交互前端改造方案.md` 将三大模块都接入统一能力：
  - 提交：全部通过 `usePageSubmission` Hook；
  - 计时：使用 `TimerService + TimerDisplay`；
  - 页面框架：统一使用 `AssessmentPageFrame` + `LeftStepperNav`；
  - Flow 观测：启用 `flow_context` 事件与 `[flowId/submoduleId/stepIndex]` 前缀。
- 拆分子模块时，保证：
  - 交互部分与问卷部分都使用相同的提交/计时/页面框架，只是 `navigationMode` 和 `getDefaultTimers` 配置不同；
  - 旧的页面级提交函数、计时器全迁移到统一层，只在必要时保留兼容读取逻辑。

#### 问题 3：登录路由与 Flow 入口的兼容

- 现状：
  - 旧架构下，登录后的 `url` 通常是 `/seven-grade`、`/four-grade` 或 `/grade-7-tracking`；
  - 新架构希望对于绑定 Flow 的批次，直接返回 `/flow/<flowId>`；
  - 但在过渡期内，会同时存在“直接进模块”与“进 Flow 再加载子模块”的批次。
- 影响：
  - 若前端只按旧逻辑处理 `url`，无法正确进入 Flow；
  - 若后端直接切到 Flow，而部分前端逻辑仍假设是单模块模式，可能导致页面恢复、计时器状态异常。

**解决思路：**
- 按 `docs/需求-后端接口与数据模型.md` 的规范：
  - 旧批次继续返回旧式 `{ url: '/seven-grade', pageNum: 'xx' }`；
  - 绑定 Flow 的批次返回 `/flow/<flowId>` 与 `progress` 字段；
  - 保留 `pageNum` 作为兼容字段。
- 前端 App 层：
  - 检测 `url` 是否以 `/flow/` 开头；
  - 若是：
    - 交给 `FlowModule`；
    - FlowModule 内部使用 `flowId` + `progress` 恢复子模块与页码；
  - 若否：
    - 走现有 `ModuleRouter` 流程。

#### 问题 4：子模块拆分后对原“整体模块”行为的影响

- 现状：
  - 原“7 年级交互模块”内部逻辑（作业流程、教研预期）是基于“实验 + 问卷”一体化设计的；
  - 原“7 年级追踪”也类似；
  - 拆成 `g7-experiment` / `g7-questionnaire` 等子模块后，需要确保：
    - 独立运行的子模块仍然能按原有评测逻辑工作；
    - 拼装成 Flow 后，整体体验符合新的“统一平台”要求。
- 影响：
  - 若拆分不当，可能出现：
    - 单独运行问卷子模块时，缺少前置上下文；
    - Flow 链路中，计时器或页面映射与原单模块不一致。

**解决思路：**
- 在 CMI 包装器中增加适配层：
  - 对每个子模块，明确：
    - 入口页（如注意事项页 / 第一题）；
    - 完成页（总结 / 提交完成页）；
    - 计时器策略（任务计时 vs 问卷计时）。
  - 对需要依赖前置信息的页面，通过 `userContext` 或 `flow_context` 补充必要字段。
- 使用统一的验收脚本与规格：
  - 参照 `docs/UNIFIED_PLATFORM_VERIFICATION_REPORT.md`、各 Phase 的验证报告；
  - 在子模块拆分后，重新验证：
    - 刷新不重置；
    - 每次下一页前提交；
    - 超时自动跳转；
    - 401 统一回登录；
    - Flow 中的 pageDesc 前缀与后端观测对齐。

### 3.4 总结：如何安全完成 3 → 5 的演进

综合上述分析，安全演进路径可以概括为：

1. **先统一能力，再拆分子模块**
   - 在不改变 URL 与外部行为的前提下：
     - 把三个原有模块全部接入统一提交/计时/页面框架；
     - 完整通过 Assessment Core 与 Data Format Spec 的验收。

2. **在模块内部用配置和包装器拆分子模块**
   - 利用 CMI 包装器，将原模块内部的“实验部分 / 问卷部分 / 追踪段落”映射为独立子模块；
   - 每个子模块都负责自己的页码范围、计时规则、结束条件。

3. **管理后台与后端同步注册 5 个子模块**
   - 按 `docs/SUBMODULE_REGISTRATION_GUIDE.md` 的表格，在管理端完成 5 个 `submoduleId` 的注册；
   - 后端 FlowDefinition 中严格使用这些 `submoduleId`。

4. **切批次到 Flow 模式，并保持旧批次兼容**
   - 新批次通过管理后台绑定 Flow，登录时返回 `/flow/<flowId>` 与 `progress`；
   - 旧批次继续使用原来的模块 URL 和页码；
   - 确保前端在两种模式下都能正常登录与恢复。

5. **持续通过统一验收文档与脚本回归**
   - 参考 `docs/flow-architecture-analysis.md`、`docs/UNIFIED_PLATFORM_VERIFICATION_REPORT.md` 及各 Phase 报告；
   - 特别关注：
     - Flow 心跳与进度回写；
     - 提交数据中的 `pageNumber/pageDesc/flow_context` 一致性；
     - 5 个子模块在不同 Flow 组合下的行为稳定性。

通过上述路径，可以在不破坏既有评测逻辑的前提下，将原来的三个交互端平滑演进成 5 个可复用的子模块，并在登录与数据提交两个关键环节上与后端建立清晰、稳定的交互规范。

